<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - NURBS</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
			p {
				color: #08f;
				font-size: 1.5em;
			}
		</style>
	</head>
	<body>
		<div id="info">
			<p>CG2122 MOD2</p>
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>
   35 
   36         <script type="module">
   37 
   38             import * as THREE from 'three';
   39 
   40             import Stats from 'three/addons/libs/stats.module.js';
   41 
   42             import { NURBSCurve } from 'three/addons/curves/NURBSCurve.js';
   43             import { NURBSSurface } from 'three/addons/curves/NURBSSurface.js';
   44             import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
   45 
   46             let container, stats;
   47 
   48             let camera, scene, renderer;
   49             let group;
   50 
   51             let targetRotation = 0;
   52             let targetRotationOnPointerDown = 0;
   53 
   54             let pointerX = 0;
   55             let pointerXOnPointerDown = 0;
   56 
   57             let windowHalfX = window.innerWidth / 2;
   58 
   59             init();
   60             animate();
   61 
   62             function init() {
   63 
   64                 container = document.createElement( 'div' );
   65                 document.body.appendChild( container );
   66 
   67                 camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 2000 );
   68                 camera.position.set( 0, 150, 750 );
   69 
   70                 scene = new THREE.Scene();
   71                 scene.background = new THREE.Color( 0xf0f0f0 );
   72 
   73                 scene.add( new THREE.AmbientLight( 0x808080 ) );
   74 
   75                 const light = new THREE.DirectionalLight( 0xffffff, 1 );
   76                 light.position.set( 1, 1, 1 );
   77                 scene.add( light );
   78 
   79                 group = new THREE.Group();
   80                 group.position.y = 50;
   81                 scene.add( group );
   82 
   83                 // NURBS curve
   84 
   85                 const nurbsControlPoints = [];
   86                 const nurbsKnots = [];
   87                 const nurbsDegree = 3;
   88 
   89                 for ( let i = 0; i <= nurbsDegree; i ++ ) {
   90 
   91                     nurbsKnots.push( 0 );
   92 
   93                 }
   94 
   95                 for ( let i = 0, j = 20; i < j; i ++ ) {
   96 
   97                     nurbsControlPoints.push(
   98                         new THREE.Vector4(
   99                             Math.random() * 400 - 200,
  100                             Math.random() * 400,
  101                             Math.random() * 400 - 200,
  102                             1 // weight of control point: higher means stronger attraction
  103                         )
  104                     );
  105 
  106                     const knot = ( i + 1 ) / ( j - nurbsDegree );
  107                     nurbsKnots.push( THREE.MathUtils.clamp( knot, 0, 1 ) );
  108 
  109                 }
  110 
  111                 const nurbsCurve = new NURBSCurve( nurbsDegree, nurbsKnots, nurbsControlPoints );
  112 
  113                 const nurbsGeometry = new THREE.BufferGeometry();
  114                 nurbsGeometry.setFromPoints( nurbsCurve.getPoints( 200 ) );
  115 
  116                 const nurbsMaterial = new THREE.LineBasicMaterial( { color: 0x333333 } );
  117 
  118                 const nurbsLine = new THREE.Line( nurbsGeometry, nurbsMaterial );
  119                 nurbsLine.position.set( 200, - 100, 0 );
  120                 group.add( nurbsLine );
  121 
  122                 const nurbsControlPointsGeometry = new THREE.BufferGeometry();
  123                 nurbsControlPointsGeometry.setFromPoints( nurbsCurve.controlPoints );
  124 
  125                 const nurbsControlPointsMaterial = new THREE.LineBasicMaterial( { color: 0x333333, opacity: 0.25, transparent: true } );
  126 
  127                 const nurbsControlPointsLine = new THREE.Line( nurbsControlPointsGeometry, nurbsControlPointsMaterial );
  128                 nurbsControlPointsLine.position.copy( nurbsLine.position );
  129                 group.add( nurbsControlPointsLine );
  130 
  131                 // NURBS surface
  132 
  133                 const nsControlPoints = [
  134                     [
  135                         new THREE.Vector4( - 200, - 200, 100, 1 ),
  136                         new THREE.Vector4( - 200, - 100, - 200, 1 ),
  137                         new THREE.Vector4( - 200, 100, 250, 1 ),
  138                         new THREE.Vector4( - 200, 200, - 100, 1 )
  139                     ],
  140                     [
  141                         new THREE.Vector4( 0, - 200, 0, 1 ),
  142                         new THREE.Vector4( 0, - 100, - 100, 5 ),
  143                         new THREE.Vector4( 0, 100, 150, 5 ),
  144                         new THREE.Vector4( 0, 200, 0, 1 )
  145                     ],
  146                     [
  147                         new THREE.Vector4( 200, - 200, - 100, 1 ),
  148                         new THREE.Vector4( 200, - 100, 200, 1 ),
  149                         new THREE.Vector4( 200, 100, - 250, 1 ),
  150                         new THREE.Vector4( 200, 200, 100, 1 )
  151                     ]
  152                 ];
  153                 const degree1 = 2;
  154                 const degree2 = 3;
  155                 const knots1 = [ 0, 0, 0, 1, 1, 1 ];
  156                 const knots2 = [ 0, 0, 0, 0, 1, 1, 1, 1 ];
  157                 const nurbsSurface = new NURBSSurface( degree1, degree2, knots1, knots2, nsControlPoints );
  158 
  159                 const map = new THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg' );
  160                 map.wrapS = map.wrapT = THREE.RepeatWrapping;
  161                 map.anisotropy = 16;
  162 
  163                 function getSurfacePoint( u, v, target ) {
  164 
  165                     return nurbsSurface.getPoint( u, v, target );
  166 
  167                 }
  168 
  169                 const geometry = new ParametricGeometry( getSurfacePoint, 20, 20 );
  170                 const material = new THREE.MeshLambertMaterial( { map: map, side: THREE.DoubleSide } );
  171                 const object = new THREE.Mesh( geometry, material );
  172                 object.position.set( - 200, 100, 0 );
  173                 object.scale.multiplyScalar( 1 );
  174                 group.add( object );
  175 
  176                 //
  177 
  178                 renderer = new THREE.WebGLRenderer( { antialias: true } );
  179                 renderer.setPixelRatio( window.devicePixelRatio );
  180                 renderer.setSize( window.innerWidth, window.innerHeight );
  181                 container.appendChild( renderer.domElement );
  182 
  183                 stats = new Stats();
  184                 container.appendChild( stats.dom );
  185 
  186                 container.style.touchAction = 'none';
  187                 container.addEventListener( 'pointerdown', onPointerDown );
  188 
  189                 //
  190 
  191                 window.addEventListener( 'resize', onWindowResize );
  192 
  193             }
  194 
  195             function onWindowResize() {
  196 
  197                 windowHalfX = window.innerWidth / 2;
  198 
  199                 camera.aspect = window.innerWidth / window.innerHeight;
  200                 camera.updateProjectionMatrix();
  201 
  202                 renderer.setSize( window.innerWidth, window.innerHeight );
  203 
  204             }
  205 
  206             //
  207 
  208             function onPointerDown( event ) {
  209 
  210                 if ( event.isPrimary === false ) return;
  211 
  212                 pointerXOnPointerDown = event.clientX - windowHalfX;
  213                 targetRotationOnPointerDown = targetRotation;
  214 
  215                 document.addEventListener( 'pointermove', onPointerMove );
  216                 document.addEventListener( 'pointerup', onPointerUp );
  217 
  218             }
  219 
  220             function onPointerMove( event ) {
  221 
  222                 if ( event.isPrimary === false ) return;
  223 
  224                 pointerX = event.clientX - windowHalfX;
  225 
  226                 targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;
  227 
  228             }
  229 
  230             function onPointerUp() {
  231 
  232                 if ( event.isPrimary === false ) return;
  233 
  234                 document.removeEventListener( 'pointermove', onPointerMove );
  235                 document.removeEventListener( 'pointerup', onPointerUp );
  236 
  237             }
  238 
  239             //
  240 
  241             function animate() {
  242 
  243                 requestAnimationFrame( animate );
  244 
  245                 render();
  246                 stats.update();
  247 
  248             }
  249 
  250             function render() {
  251 
  252                 group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
  253                 renderer.render( scene, camera );
  254 
  255             }
  256 
  257         </script>
  258 
  259     </body>
  260 </html>